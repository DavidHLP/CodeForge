# SpringOJ 微服务权限信息传递系统 - 最佳实践

## 1. 高可用性设计

### 1.1 网关高可用配置

**负载均衡与故障转移：**

```yaml
# application.yml
spring:
  cloud:
    gateway:
      # 负载均衡配置
      loadbalancer:
        retry:
          enabled: true
          max-retries: 3
          retry-on-all-operations: false
          retry-on-status-codes: 502,503,504

    # 熔断器配置
    circuitbreaker:
      hystrix:
        enabled: true
      config:
        default:
          failure-rate-threshold: 50
          wait-duration-in-open-state: 30s
          sliding-window-size: 10
```

**多实例部署策略：**

```yaml
# docker-compose.yml
services:
  gateway-1:
    image: springoj-gateway:latest
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - SERVER_PORT=8080
    ports:
      - "8080:8080"

  gateway-2:
    image: springoj-gateway:latest
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - SERVER_PORT=8080
    ports:
      - "8081:8080"

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
```

### 1.2 认证服务高可用

**缓存策略优化：**

```java
@Configuration
@EnableCaching
public class CacheConfig {

    @Bean
    public CacheManager cacheManager() {
        RedisCacheManager.Builder builder = RedisCacheManager
                .RedisCacheManagerBuilder
                .fromConnectionFactory(redisConnectionFactory())
                .cacheDefaults(cacheConfiguration());
        return builder.build();
    }

    private RedisCacheConfiguration cacheConfiguration() {
        return RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10)) // Token缓存10分钟
                .serializeKeysWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new StringRedisSerializer()))
                .serializeValuesWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new GenericJackson2JsonRedisSerializer()));
    }
}

@Service
public class CachedAuthService {

    @Cacheable(value = "auth:tokens", key = "#token", unless = "#result == null")
    public AuthUserInfo validateToken(String token) {
        // 实际的token验证逻辑
        return authService.validateToken(token);
    }

    @CacheEvict(value = "auth:tokens", key = "#token")
    public void invalidateToken(String token) {
        // 失效token缓存
    }
}
```

## 2. 性能优化

### 2.1 网关性能调优

**线程池配置：**

```yaml
# application.yml
spring:
  cloud:
    gateway:
      # 全局超时配置
      httpclient:
        connect-timeout: 3000
        response-timeout: 10s
        pool:
          type: elastic
          max-connections: 500
          max-idle-time: 30s

server:
  netty:
    # Netty配置优化
    connection-timeout: 3000ms
    idle-timeout: 30s
```

**JVM调优参数：**

```bash
# 启动参数
java -server \
  -Xms2g -Xmx2g \
  -XX:+UseG1GC \
  -XX:MaxGCPauseMillis=100 \
  -XX:+UseStringDeduplication \
  -Dio.netty.allocator.type=pooled \
  -Dio.netty.recycler.maxCapacityPerThread=0 \
  -jar gateway.jar
```

### 2.2 认证缓存策略

**多级缓存实现：**

```java
@Component
public class MultiLevelAuthCache {

    private final LoadingCache<String, AuthUserInfo> localCache;
    private final RedisTemplate<String, AuthUserInfo> redisTemplate;

    public MultiLevelAuthCache() {
        this.localCache = Caffeine.newBuilder()
                .maximumSize(1000)
                .expireAfterWrite(5, TimeUnit.MINUTES)
                .build(this::loadFromRedis);
    }

    public Optional<AuthUserInfo> getAuthUser(String token) {
        try {
            return Optional.ofNullable(localCache.get(token));
        } catch (Exception e) {
            return Optional.empty();
        }
    }

    private AuthUserInfo loadFromRedis(String token) {
        String key = "auth:token:" + token;
        return redisTemplate.opsForValue().get(key);
    }

    public void putAuthUser(String token, AuthUserInfo userInfo) {
        // 同时更新本地缓存和Redis
        localCache.put(token, userInfo);
        String key = "auth:token:" + token;
        redisTemplate.opsForValue().set(key, userInfo, Duration.ofMinutes(10));
    }
}
```

## 3. 错误处理与监控

### 3.1 统一异常处理

**网关异常处理器：**

```java
@Component
@Order(-1)
public class GlobalGatewayExceptionHandler implements ErrorWebExceptionHandler {

    @Override
    public Mono<Void> handle(ServerWebExchange exchange, Throwable ex) {
        ServerHttpResponse response = exchange.getResponse();

        if (ex instanceof TimeoutException) {
            return handleTimeoutException(response, ex);
        } else if (ex instanceof ConnectException) {
            return handleConnectionException(response, ex);
        } else if (ex instanceof ResponseStatusException) {
            return handleResponseStatusException(response, (ResponseStatusException) ex);
        }

        return handleGenericException(response, ex);
    }

    private Mono<Void> handleTimeoutException(ServerHttpResponse response, Throwable ex) {
        response.setStatusCode(HttpStatus.GATEWAY_TIMEOUT);
        return writeErrorResponse(response, 504, "服务请求超时", null);
    }

    private Mono<Void> writeErrorResponse(ServerHttpResponse response,
                                        int code, String message, Object data) {
        response.getHeaders().add("Content-Type", "application/json;charset=UTF-8");

        ErrorResponse errorResponse = ErrorResponse.builder()
                .code(code)
                .message(message)
                .data(data)
                .timestamp(System.currentTimeMillis())
                .build();

        String body = JsonUtils.toJson(errorResponse);
        return response.writeWith(Mono.just(response.bufferFactory().wrap(body.getBytes())));
    }
}
```

### 3.2 限流与熔断

**Redis分布式限流：**

```java
@Component
public class RedisRateLimiter {

    private final RedisTemplate<String, String> redisTemplate;
    private final String luaScript = """
        local key = KEYS[1]
        local window = tonumber(ARGV[1])
        local limit = tonumber(ARGV[2])
        local current = redis.call('INCR', key)
        if current == 1 then
            redis.call('EXPIRE', key, window)
        end
        if current > limit then
            return 0
        else
            return 1
        end
        """;

    public boolean isAllowed(String userId, int windowSeconds, int limit) {
        String key = "rate_limit:user:" + userId;
        DefaultRedisScript<Long> script = new DefaultRedisScript<>(luaScript, Long.class);

        Long result = redisTemplate.execute(script,
                Collections.singletonList(key),
                String.valueOf(windowSeconds),
                String.valueOf(limit));

        return result != null && result == 1;
    }
}

@Component
public class RateLimitFilter implements GlobalFilter, Ordered {

    private final RedisRateLimiter rateLimiter;

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String userId = exchange.getRequest().getHeaders().getFirst("X-User-Id");

        if (userId != null) {
            boolean allowed = rateLimiter.isAllowed(userId, 60, 100); // 每分钟100次
            if (!allowed) {
                return handleRateLimitExceeded(exchange.getResponse());
            }
        }

        return chain.filter(exchange);
    }

    @Override
    public int getOrder() {
        return -50; // 在认证过滤器之后
    }
}
```

### 3.3 监控与告警

**自定义指标监控：**

```java
@Component
public class AuthMetrics {

    private final MeterRegistry meterRegistry;
    private final Counter authSuccessCounter;
    private final Counter authFailureCounter;
    private final Timer authDurationTimer;

    public AuthMetrics(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.authSuccessCounter = Counter.builder("auth.success")
                .description("认证成功次数")
                .register(meterRegistry);
        this.authFailureCounter = Counter.builder("auth.failure")
                .description("认证失败次数")
                .tag("reason", "unknown")
                .register(meterRegistry);
        this.authDurationTimer = Timer.builder("auth.duration")
                .description("认证耗时")
                .register(meterRegistry);
    }

    public void recordAuthSuccess() {
        authSuccessCounter.increment();
    }

    public void recordAuthFailure(String reason) {
        authFailureCounter.increment(Tags.of("reason", reason));
    }

    public Timer.Sample startAuthTimer() {
        return Timer.start(meterRegistry);
    }
}
```

## 4. 安全最佳实践

### 4.1 Token安全

**JWT Token最佳实践：**

```java
@Service
public class SecureTokenService {

    private final JwtTokenProvider tokenProvider;
    private final RedisTemplate<String, String> redisTemplate;

    /**
     * 生成安全的JWT Token
     */
    public String generateSecureToken(AuthUser user) {
        String jti = UUID.randomUUID().toString();

        Claims claims = Jwts.claims()
                .setSubject(user.getUsername())
                .setId(jti)
                .setIssuedAt(new Date())
                .setExpiration(Date.from(Instant.now().plus(2, ChronoUnit.HOURS)));

        claims.put("userId", user.getUserId());
        claims.put("roles", user.getRoleName());

        String token = tokenProvider.createToken(claims);

        // 将JTI存储到Redis，用于token撤销
        String key = "token:jti:" + jti;
        redisTemplate.opsForValue().set(key, token, Duration.ofHours(2));

        return token;
    }

    /**
     * 验证Token并检查是否被撤销
     */
    public boolean validateToken(String token) {
        try {
            Claims claims = tokenProvider.getClaimsFromToken(token);
            String jti = claims.getId();

            // 检查Token是否被撤销
            String key = "token:jti:" + jti;
            return redisTemplate.hasKey(key);
        } catch (Exception e) {
            return false;
        }
    }

    /**
     * 撤销Token
     */
    public void revokeToken(String token) {
        try {
            Claims claims = tokenProvider.getClaimsFromToken(token);
            String jti = claims.getId();
            String key = "token:jti:" + jti;
            redisTemplate.delete(key);
        } catch (Exception e) {
            log.warn("撤销Token失败: {}", e.getMessage());
        }
    }
}
```

### 4.2 请求头安全

**敏感信息过滤：**

```java
@Component
public class SecurityHeaderFilter implements GlobalFilter, Ordered {

    private static final Set<String> SENSITIVE_HEADERS = Set.of(
            "authorization", "x-user-id", "x-user-name",
            "x-user-email", "x-user-roles"
    );

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();

        // 移除客户端可能伪造的用户信息头
        ServerHttpRequest.Builder builder = request.mutate();
        SENSITIVE_HEADERS.forEach(header ->
                builder.headers(headers -> headers.remove(header)));

        ServerHttpRequest secureRequest = builder.build();
        return chain.filter(exchange.mutate().request(secureRequest).build());
    }

    @Override
    public int getOrder() {
        return -200; // 最高优先级
    }
}
```

## 5. 部署与运维

### 5.1 容器化部署

**Dockerfile优化：**

```dockerfile
# 多阶段构建
FROM eclipse-temurin:17-jdk-alpine AS builder
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN ./mvnw clean package -DskipTests

FROM eclipse-temurin:17-jre-alpine
RUN addgroup -g 1001 -S springoj && adduser -u 1001 -S springoj -G springoj
COPY --from=builder /app/target/*.jar app.jar
RUN chown springoj:springoj app.jar
USER springoj
EXPOSE 8080

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s \
    CMD wget --no-verbose --tries=1 --spider http://localhost:8080/actuator/health || exit 1

ENTRYPOINT ["java", "-jar", "app.jar"]
```

### 5.2 Kubernetes部署

**完整的K8s配置：**

```yaml
# gateway-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: springoj-gateway
spec:
  replicas: 3
  selector:
    matchLabels:
      app: springoj-gateway
  template:
    metadata:
      labels:
        app: springoj-gateway
    spec:
      containers:
        - name: gateway
          image: springoj/gateway:latest
          ports:
            - containerPort: 8080
          env:
            - name: SPRING_PROFILES_ACTIVE
              value: "k8s"
          resources:
            requests:
              memory: "512Mi"
              cpu: "500m"
            limits:
              memory: "1Gi"
              cpu: "1000m"
          livenessProbe:
            httpGet:
              path: /actuator/health/liveness
              port: 8080
            initialDelaySeconds: 60
            periodSeconds: 30
          readinessProbe:
            httpGet:
              path: /actuator/health/readiness
              port: 8080
            initialDelaySeconds: 30
            periodSeconds: 10
---
apiVersion: v1
kind: Service
metadata:
  name: springoj-gateway-service
spec:
  selector:
    app: springoj-gateway
  ports:
    - port: 80
      targetPort: 8080
  type: LoadBalancer
```

---

**上一章节：** [04-使用示例.md](./04-使用示例.md)  
**下一章节：** [06-未来规划.md](./06-未来规划.md)
