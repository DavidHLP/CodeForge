# SpringOJ 微服务权限信息传递系统 - 使用示例

## 1. 网关服务配置示例

### 1.1 Gateway 配置文件

**application.yml 完整配置**

```yaml
server:
  port: 8080

spring:
  application:
    name: gateway

  cloud:
    gateway:
      # 路由配置
      routes:
        - id: auth-service
          uri: lb://authentication
          predicates:
            - Path=/api/auth/**
          filters:
            - StripPrefix=0

        - id: user-service
          uri: lb://user-service
          predicates:
            - Path=/api/user/**
          filters:
            - StripPrefix=0

        - id: problem-service
          uri: lb://problem-service
          predicates:
            - Path=/api/problems/**
          filters:
            - StripPrefix=0

      # 全局CORS配置
      globalcors:
        cors-configurations:
          "[/**]":
            allowedOriginPatterns: "*"
            allowedMethods: "*"
            allowedHeaders: "*"
            allowCredentials: true

    # Nacos服务发现
    nacos:
      discovery:
        server-addr: localhost:8848
        namespace: springoj
        group: DEFAULT_GROUP

  # Security配置
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://localhost:8081

# Actuator监控端点
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,gateway

# 日志配置
logging:
  level:
    com.david.filter.AuthGlobalFilter: DEBUG
    org.springframework.cloud.gateway: INFO
    org.springframework.security: DEBUG
```

### 1.2 AuthGlobalFilter 使用示例

**完整的AuthGlobalFilter实现：**

```java
@Slf4j
@Component
public class AuthGlobalFilter implements GlobalFilter, Ordered {

    @Lazy
    @Resource
    private AuthFeignClient authFeignClient;

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String path = request.getURI().getPath();

        log.info("处理请求: {} {}", request.getMethod(), path);

        // 检查是否为公开路径
        if (isPublicPath(path)) {
            log.debug("公开路径，直接放行: {}", path);
            return chain.filter(exchange);
        }

        // 提取并验证JWT Token
        String token = extractToken(request);
        if (token == null) {
            log.warn("请求缺少有效的 Authorization 头");
            return handleUnauthorized(exchange.getResponse(), "缺少有效的认证令牌");
        }

        // 异步验证Token并注入用户信息
        return authenticateAndInjectUserInfo(token, exchange, chain);
    }

    /**
     * 异步认证并注入用户信息
     */
    private Mono<Void> authenticateAndInjectUserInfo(String token,
                                                    ServerWebExchange exchange,
                                                    GatewayFilterChain chain) {
        return Mono.fromCallable(() -> {
            try {
                ResponseResult<AuthUserInfo> result = authFeignClient.loadUserByUsername(token);
                if (result == null || result.getData() == null) {
                    throw new RuntimeException("认证服务返回空结果");
                }
                return result.getData();
            } catch (Exception e) {
                log.error("认证服务调用异常: {}", e.getMessage(), e);
                throw new RuntimeException("认证服务异常: " + e.getMessage(), e);
            }
        })
        .subscribeOn(Schedulers.boundedElastic()) // 使用弹性调度器处理阻塞调用
        .flatMap(authUser -> {
            log.info("用户认证成功: {}", authUser.getUsername());

            // 注入用户信息到请求头
            ServerHttpRequest mutatedRequest = injectUserHeaders(exchange.getRequest(), authUser);
            return chain.filter(exchange.mutate().request(mutatedRequest).build());
        })
        .onErrorResume(throwable -> {
            log.error("认证过程中发生异常: {}", throwable.getMessage());
            return handleUnauthorized(exchange.getResponse(), "认证失败: " + throwable.getMessage());
        });
    }

    /**
     * 注入用户信息到请求头
     */
    private ServerHttpRequest injectUserHeaders(ServerHttpRequest request, AuthUserInfo authUser) {
        String roleName = authUser.getRole() != null ? authUser.getRole().getRoleName() : "USER";

        return request.mutate()
                .header("X-User-Id", String.valueOf(authUser.getUserId()))
                .header("X-User-Name", Objects.toString(authUser.getUsername(), ""))
                .header("X-User-Email", Objects.toString(authUser.getEmail(), ""))
                .header("X-User-Roles", roleName)
                .build();
    }

    @Override
    public int getOrder() {
        return -100; // 最高优先级
    }
}
```

### 1.3 OpenFeign 客户端配置

**AuthFeignClient 完整配置：**

```java
@FeignClient(
    name = "authentication",
    path = "/api/auth",
    configuration = FeignClientConfig.class
)
public interface AuthFeignClient {

    @GetMapping("/validate/{token}")
    ResponseResult<AuthUserInfo> loadUserByUsername(@PathVariable("token") String token);

    @GetMapping("/user/{userId}")
    ResponseResult<AuthUserInfo> getUserById(@PathVariable("userId") Long userId);
}

/**
 * Feign客户端配置类
 */
@Configuration
public class FeignClientConfig {

    @Bean
    public Logger.Level feignLoggerLevel() {
        return Logger.Level.BASIC;
    }

    @Bean
    public RequestInterceptor requestInterceptor() {
        return requestTemplate -> {
            // 添加公共请求头
            requestTemplate.header("Content-Type", "application/json");
            requestTemplate.header("Accept", "application/json");
        };
    }

    @Bean
    public ErrorDecoder errorDecoder() {
        return new FeignErrorDecoder();
    }
}

/**
 * Feign异常解码器
 */
public class FeignErrorDecoder implements ErrorDecoder {

    @Override
    public Exception decode(String methodKey, Response response) {
        String message = String.format("认证服务调用失败 [%s] %s",
                                     response.status(), methodKey);

        switch (response.status()) {
            case 401:
                return new UnauthorizedException("Token无效或已过期");
            case 404:
                return new UserNotFoundException("用户不存在");
            case 500:
                return new ServiceException("认证服务内部错误");
            default:
                return new RuntimeException(message);
        }
    }
}
```

## 2. 下游服务集成示例

### 2.1 Controller层使用示例

**用户服务Controller示例：**

```java
@RestController
@RequestMapping("/api/user")
@Validated
@RequiredArgsConstructor
public class UserController extends BaseController {

    private final UserService userService;

    /**
     * 获取当前用户信息
     * 从SecurityContext中获取认证用户
     */
    @GetMapping("/profile")
    public ResponseResult<UserProfileVO> getCurrentUserProfile(HttpServletRequest request) {
        // 方式1：使用UserContextUtil工具类
        Optional<Long> userIdOpt = UserContextUtil.getCurrentUserId(request);
        if (userIdOpt.isEmpty()) {
            return ResponseResult.fail("用户未认证");
        }

        Long userId = userIdOpt.get();
        UserProfileVO profile = userService.getUserProfile(userId);
        return ResponseResult.success(profile);
    }

    /**
     * 获取用户列表 - 管理员权限
     * 使用@PreAuthorize进行权限控制
     */
    @GetMapping("/list")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseResult<PageResult<UserListVO>> getUserList(
            @RequestParam(defaultValue = "1") Integer current,
            @RequestParam(defaultValue = "10") Integer size,
            @RequestParam(required = false) String keyword,
            HttpServletRequest request) {

        // 记录操作日志
        String operatorName = UserContextUtil.getCurrentUsername(request).orElse("未知用户");
        log.info("管理员 {} 查询用户列表", operatorName);

        PageResult<UserListVO> result = userService.getUserList(current, size, keyword);
        return ResponseResult.success(result);
    }

    /**
     * 更新用户信息 - 只能更新自己的信息
     */
    @PutMapping("/{userId}")
    @PreAuthorize("@userService.canUpdateUser(#userId, authentication)")
    public ResponseResult<Void> updateUser(
            @PathVariable Long userId,
            @Valid @RequestBody UpdateUserRequest request,
            HttpServletRequest httpRequest) {

        // 验证是否为当前用户
        if (!UserContextUtil.isCurrentUser(httpRequest, userId)) {
            return ResponseResult.fail("无权限操作其他用户信息");
        }

        userService.updateUser(userId, request);
        return ResponseResult.success();
    }

    /**
     * 删除用户 - 管理员权限且不能删除自己
     */
    @DeleteMapping("/{userId}")
    @PreAuthorize("hasRole('ADMIN') and #userId != authentication.principal.userId")
    public ResponseResult<Void> deleteUser(@PathVariable Long userId,
                                         HttpServletRequest request) {

        String operatorName = UserContextUtil.getCurrentUsername(request).orElse("管理员");
        log.info("管理员 {} 删除用户: {}", operatorName, userId);

        userService.deleteUser(userId);
        return ResponseResult.success();
    }
}
```

### 2.2 Service层权限判断示例

**UserService 权限判断方法：**

```java
@Service
@RequiredArgsConstructor
public class UserService {

    private final UserRepository userRepository;

    /**
     * 自定义权限判断方法
     * 用于@PreAuthorize表达式
     */
    public boolean canUpdateUser(Long targetUserId, Authentication authentication) {
        if (authentication == null || authentication.getPrincipal() == null) {
            return false;
        }

        AuthUser currentUser = (AuthUser) authentication.getPrincipal();

        // 管理员可以更新任何用户
        if (currentUser.isAdmin()) {
            return true;
        }

        // 普通用户只能更新自己的信息
        return Objects.equals(currentUser.getUserId(), targetUserId);
    }

    /**
     * 获取用户详情 - 带权限控制
     */
    public UserDetailVO getUserDetail(Long userId, Long currentUserId, boolean isAdmin) {
        UserDetailVO detail = userRepository.getUserDetail(userId);

        // 非管理员且不是自己，只返回公开信息
        if (!isAdmin && !Objects.equals(userId, currentUserId)) {
            detail.setEmail("***");
            detail.setPhone("***");
            detail.setAddress("***");
        }

        return detail;
    }

    /**
     * 审核用户 - 只有管理员可以执行
     */
    @PreAuthorize("hasRole('ADMIN')")
    public void auditUser(Long userId, AuditRequest request) {
        // 业务逻辑
        userRepository.updateUserStatus(userId, request.getStatus());

        // 记录审核日志
        AuthUser currentUser = getCurrentUser();
        auditLogService.recordAudit(currentUser.getUserId(), userId, request);
    }

    /**
     * 获取当前认证用户
     */
    private AuthUser getCurrentUser() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthUser) {
            return (AuthUser) authentication.getPrincipal();
        }
        throw new UnauthorizedException("用户未认证");
    }
}
```

### 2.3 BaseController 基础控制器

**提供通用的用户信息获取方法：**

```java
@Slf4j
public abstract class BaseController {

    /**
     * 获取当前用户ID
     */
    protected Long getCurrentUserId(HttpServletRequest request) {
        return UserContextUtil.getCurrentUserId(request)
                .orElseThrow(() -> new UnauthorizedException("用户未认证"));
    }

    /**
     * 获取当前用户名
     */
    protected String getCurrentUsername(HttpServletRequest request) {
        return UserContextUtil.getCurrentUsername(request)
                .orElse("匿名用户");
    }

    /**
     * 获取当前用户完整信息
     */
    protected AuthUser getCurrentUser(HttpServletRequest request) {
        return UserContextUtil.getCurrentAuthUser(request)
                .orElseThrow(() -> new UnauthorizedException("用户信息获取失败"));
    }

    /**
     * 检查是否为管理员
     */
    protected boolean isAdmin(HttpServletRequest request) {
        return UserContextUtil.isAdmin(request);
    }

    /**
     * 检查是否有指定角色
     */
    protected boolean hasRole(HttpServletRequest request, String role) {
        return UserContextUtil.hasRole(request, role);
    }

    /**
     * 验证操作权限 - 只能操作自己的数据
     */
    protected void checkUserPermission(HttpServletRequest request, Long targetUserId) {
        Long currentUserId = getCurrentUserId(request);
        if (!Objects.equals(currentUserId, targetUserId) && !isAdmin(request)) {
            throw new AccessDeniedException("无权限操作其他用户数据");
        }
    }
}
```

## 3. WebFlux 环境使用示例

### 3.1 WebFlux Controller 示例

```java
@RestController
@RequestMapping("/api/reactive/user")
@RequiredArgsConstructor
public class ReactiveUserController {

    private final ReactiveUserService userService;

    /**
     * 获取当前用户信息 - WebFlux版本
     */
    @GetMapping("/profile")
    public Mono<ResponseResult<UserProfileVO>> getCurrentUserProfile(ServerWebExchange exchange) {
        return UserContextUtil.getCurrentUserId(exchange)
                .map(userId -> userService.getUserProfile(userId))
                .map(ResponseResult::success)
                .orElseGet(() -> Mono.just(ResponseResult.fail("用户未认证")));
    }

    /**
     * 响应式权限验证示例
     */
    @GetMapping("/secure-data")
    public Mono<ResponseResult<String>> getSecureData(ServerWebExchange exchange) {
        return Mono.fromSupplier(() -> UserContextUtil.getCurrentUserId(exchange))
                .filter(Optional::isPresent)
                .map(Optional::get)
                .flatMap(userId -> {
                    // 检查权限
                    if (UserContextUtil.isAdmin(exchange)) {
                        return Mono.just("管理员专属数据");
                    } else {
                        return Mono.just("普通用户数据");
                    }
                })
                .map(ResponseResult::success)
                .switchIfEmpty(Mono.just(ResponseResult.fail("用户未认证")));
    }
}
```

### 3.2 响应式Security配置

```java
@Configuration
@EnableWebFluxSecurity
public class ReactiveSecurityConfig {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        return http
                .csrf(ServerHttpSecurity.CsrfSpec::disable)
                .authorizeExchange(exchanges -> exchanges
                        .pathMatchers("/api/auth/**", "/actuator/**").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/problems/public/**").permitAll()
                        .pathMatchers("/api/admin/**").hasRole("ADMIN")
                        .anyExchange().authenticated()
                )
                .exceptionHandling(exceptions -> exceptions
                        .authenticationEntryPoint(customAuthenticationEntryPoint())
                        .accessDeniedHandler(customAccessDeniedHandler())
                )
                .build();
    }

    @Bean
    public ServerAuthenticationEntryPoint customAuthenticationEntryPoint() {
        return (exchange, ex) -> {
            ServerHttpResponse response = exchange.getResponse();
            response.setStatusCode(HttpStatus.UNAUTHORIZED);
            response.getHeaders().add("Content-Type", "application/json;charset=UTF-8");

            String body = "{\"code\": 401, \"message\": \"用户未认证\", \"data\": null}";
            return response.writeWith(Mono.just(response.bufferFactory().wrap(body.getBytes())));
        };
    }

    @Bean
    public ServerAccessDeniedHandler customAccessDeniedHandler() {
        return (exchange, denied) -> {
            ServerHttpResponse response = exchange.getResponse();
            response.setStatusCode(HttpStatus.FORBIDDEN);
            response.getHeaders().add("Content-Type", "application/json;charset=UTF-8");

            String body = "{\"code\": 403, \"message\": \"权限不足\", \"data\": null}";
            return response.writeWith(Mono.just(response.bufferFactory().wrap(body.getBytes())));
        };
    }
}
```

## 4. 复杂权限场景示例

### 4.1 多级权限控制

```java
@RestController
@RequestMapping("/api/problems")
@RequiredArgsConstructor
public class ProblemController extends BaseController {

    private final ProblemService problemService;

    /**
     * 获取题目详情 - 复杂权限判断
     */
    @GetMapping("/{problemId}")
    public ResponseResult<ProblemDetailVO> getProblemDetail(
            @PathVariable Long problemId,
            HttpServletRequest request) {

        Long currentUserId = getCurrentUserId(request);
        boolean isAdmin = isAdmin(request);

        // 检查题目访问权限
        ProblemAccessLevel accessLevel = problemService.checkProblemAccess(problemId, currentUserId, isAdmin);

        switch (accessLevel) {
            case FULL_ACCESS:
                return ResponseResult.success(problemService.getFullProblemDetail(problemId));
            case LIMITED_ACCESS:
                return ResponseResult.success(problemService.getLimitedProblemDetail(problemId));
            case NO_ACCESS:
                return ResponseResult.fail("无权限访问该题目");
            default:
                return ResponseResult.fail("权限验证失败");
        }
    }

    /**
     * 创建题目 - 需要特定权限
     */
    @PostMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('PROBLEM_CREATOR')")
    public ResponseResult<Long> createProblem(
            @Valid @RequestBody CreateProblemRequest request,
            HttpServletRequest httpRequest) {

        Long creatorId = getCurrentUserId(httpRequest);
        Long problemId = problemService.createProblem(request, creatorId);

        return ResponseResult.success(problemId);
    }
}

/**
 * 自定义权限评估器
 */
@Component
public class ProblemPermissionEvaluator implements PermissionEvaluator {

    @Autowired
    private ProblemService problemService;

    @Override
    public boolean hasPermission(Authentication authentication, Object targetDomainObject, Object permission) {
        if (authentication == null || !(authentication.getPrincipal() instanceof AuthUser)) {
            return false;
        }

        AuthUser user = (AuthUser) authentication.getPrincipal();
        String permissionStr = permission.toString();

        if (targetDomainObject instanceof Long) {
            Long problemId = (Long) targetDomainObject;
            return evaluateProblemPermission(user, problemId, permissionStr);
        }

        return false;
    }

    @Override
    public boolean hasPermission(Authentication authentication, Serializable targetId,
                               String targetType, Object permission) {
        return false;
    }

    private boolean evaluateProblemPermission(AuthUser user, Long problemId, String permission) {
        switch (permission) {
            case "READ":
                return problemService.canReadProblem(user, problemId);
            case "WRITE":
                return problemService.canEditProblem(user, problemId);
            case "DELETE":
                return user.isAdmin() || problemService.isProblemOwner(user.getUserId(), problemId);
            default:
                return false;
        }
    }
}
```

### 4.2 动态权限控制

```java
/**
 * 动态权限服务
 */
@Service
@RequiredArgsConstructor
public class DynamicPermissionService {

    private final RolePermissionRepository rolePermissionRepository;
    private final UserRoleRepository userRoleRepository;

    /**
     * 检查用户是否有特定权限
     */
    public boolean hasPermission(Long userId, String resource, String action) {
        // 获取用户所有角色
        List<String> userRoles = userRoleRepository.getUserRoles(userId);

        // 检查角色权限
        for (String role : userRoles) {
            if (rolePermissionRepository.hasPermission(role, resource, action)) {
                return true;
            }
        }

        return false;
    }

    /**
     * 获取用户可访问的资源列表
     */
    public List<String> getAccessibleResources(Long userId) {
        List<String> userRoles = userRoleRepository.getUserRoles(userId);
        return rolePermissionRepository.getResourcesByRoles(userRoles);
    }
}

/**
 * 使用动态权限的Controller示例
 */
@RestController
@RequestMapping("/api/admin")
@RequiredArgsConstructor
public class AdminController extends BaseController {

    private final DynamicPermissionService permissionService;
    private final AdminService adminService;

    @GetMapping("/users")
    public ResponseResult<PageResult<UserListVO>> getUserList(
            HttpServletRequest request,
            @RequestParam(defaultValue = "1") Integer current,
            @RequestParam(defaultValue = "10") Integer size) {

        Long currentUserId = getCurrentUserId(request);

        // 动态权限检查
        if (!permissionService.hasPermission(currentUserId, "user", "list")) {
            return ResponseResult.fail("无权限查看用户列表");
        }

        PageResult<UserListVO> result = adminService.getUserList(current, size);
        return ResponseResult.success(result);
    }
}
```

---

**上一章节：** [03-核心模块.md](./03-核心模块.md)  
**下一章节：** [05-最佳实践.md](./05-最佳实践.md)
