# Redis Commons - 最佳实践

## 🏗️ 连接池管理

### 连接池配置优化

```yaml
spring:
  data:
    redis:
      lettuce:
        pool:
          # 连接池最大连接数
          max-active: 20
          # 连接池最大空闲连接数
          max-idle: 10
          # 连接池最小空闲连接数
          min-idle: 5
          # 连接池最大阻塞等待时间
          max-wait: 2000ms
        # 关闭超时时间
        shutdown-timeout: 100ms
      # 连接超时时间
      connect-timeout: 2000ms
      # 读取超时时间
      timeout: 3000ms
```

### 连接池监控

```java
@Component
public class RedisConnectionMonitor {

    @Autowired
    private LettuceConnectionFactory connectionFactory;

    @Scheduled(fixedRate = 30000) // 每30秒检查一次
    public void monitorConnectionPool() {
        GenericObjectPool<?> pool = connectionFactory.getPool();
        if (pool != null) {
            log.info("Redis连接池状态 - 活跃连接: {}, 空闲连接: {}, 等待线程: {}",
                pool.getNumActive(), pool.getNumIdle(), pool.getNumWaiters());
        }
    }
}
```

## 🚀 性能优化策略

### 1. 键设计原则

```java
public class RedisKeyDesignPractice {

    // ✅ 好的键设计
    private static final String USER_PREFIX = "user:";
    private static final String SESSION_PREFIX = "session:";
    private static final String CACHE_PREFIX = "cache:";

    public String buildUserKey(Long userId) {
        return USER_PREFIX + "info:" + userId;
    }

    // ✅ 使用分隔符便于管理
    public String buildCacheKey(String module, String function, String id) {
        return CACHE_PREFIX + module + ":" + function + ":" + id;
    }

    // ❌ 避免的键设计
    // 过长的键名：user:profile:detailed:information:with:all:fields:123
    // 包含特殊字符：user info 123, user\ninfo\t123
    // 没有规范：userInfo123, user_info_123, UserInfo123
}
```

### 2. 批量操作优化

```java
@Service
public class BatchOperationPractice {

    @Autowired
    private RedisUtils redisUtils;

    /**
     * 批量获取优化
     */
    public Map<String, UserInfo> batchGetUsers(List<Long> userIds) {
        if (userIds.isEmpty()) {
            return Collections.emptyMap();
        }

        // 构建键列表
        List<String> keys = userIds.stream()
            .map(id -> "user:info:" + id)
            .collect(Collectors.toList());

        // 批量获取
        List<Object> values = redisUtils.strings().multiGet(keys);

        // 组装结果
        Map<String, UserInfo> result = new HashMap<>();
        for (int i = 0; i < keys.size(); i++) {
            if (values.get(i) != null) {
                result.put(keys.get(i), (UserInfo) values.get(i));
            }
        }

        return result;
    }

    /**
     * 分批处理大量数据
     */
    public void batchProcessLargeDataset(List<String> largeDataset) {
        int batchSize = 100;

        for (int i = 0; i < largeDataset.size(); i += batchSize) {
            int end = Math.min(i + batchSize, largeDataset.size());
            List<String> batch = largeDataset.subList(i, end);

            // 处理单个批次
            processBatch(batch);

            // 避免Redis过载，适当休息
            if (end < largeDataset.size()) {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
    }

    private void processBatch(List<String> batch) {
        Map<String, Object> batchData = new HashMap<>();
        for (String data : batch) {
            batchData.put("data:" + data, processData(data));
        }
        redisUtils.strings().multiSet(batchData);
    }
}
```

### 3. 内存使用优化

```java
@Service
public class MemoryOptimizationPractice {

    /**
     * 使用过期时间避免内存泄漏
     */
    public void setWithTtl(String key, Object value) {
        // 为所有缓存设置合理的过期时间
        redisUtils.strings().set(key, value, Duration.ofHours(2));
    }

    /**
     * 使用Hash结构优化小对象存储
     */
    public void optimizeSmallObjectStorage(String userId, Map<String, String> userFields) {
        String userKey = "user:hash:" + userId;

        // 使用Hash而不是多个String键
        redisUtils.hashes().hmset(userKey, userFields);
        redisUtils.strings().expire(userKey, Duration.ofDays(1));
    }

    /**
     * 清理过期数据
     */
    @Scheduled(cron = "0 0 2 * * ?") // 每天凌晨2点执行
    public void cleanupExpiredData() {
        String pattern = "temp:*";
        Set<String> keys = redisUtils.strings().scanKeys(pattern);

        if (!keys.isEmpty()) {
            Long deletedCount = redisUtils.strings().delete(keys.toArray(new String[0]));
            log.info("清理临时数据 {} 条", deletedCount);
        }
    }
}
```

## 🔒 分布式锁最佳实践

### 1. 锁粒度控制

```java
@Service
public class LockGranularityPractice {

    /**
     * 细粒度锁 - 推荐
     */
    public void processOrderItem(Long orderId, Long itemId) {
        String lockKey = "order:item:lock:" + orderId + ":" + itemId;

        redisUtils.locks().executeWithLock(lockKey, () -> {
            // 只锁定特定订单的特定商品
            processSpecificOrderItem(orderId, itemId);
            return null;
        });
    }

    /**
     * 粗粒度锁 - 避免
     */
    public void processOrderBad(Long orderId) {
        String lockKey = "order:lock"; // 锁定所有订单

        redisUtils.locks().executeWithLock(lockKey, () -> {
            processOrder(orderId);
            return null;
        });
    }

    /**
     * 层级锁策略
     */
    public void processWithHierarchicalLock(String userId, String resourceId) {
        // 先获取用户级锁
        String userLock = "user:lock:" + userId;

        redisUtils.locks().executeWithLock(userLock, Duration.ofSeconds(5),
            Duration.ofSeconds(30), () -> {
                // 再获取资源级锁
                String resourceLock = "resource:lock:" + resourceId;

                return redisUtils.locks().executeWithLock(resourceLock,
                    Duration.ofSeconds(2), Duration.ofSeconds(10), () -> {
                        processUserResource(userId, resourceId);
                        return null;
                    });
            });
    }
}
```

### 2. 锁超时与重试策略

```java
@Service
public class LockTimeoutPractice {

    /**
     * 合理的锁超时配置
     */
    public void lockTimeoutExample() {
        // 快速操作：短等待时间，短持有时间
        redisUtils.locks().executeWithLock("quick:lock",
            Duration.ofSeconds(1),   // 等待1秒
            Duration.ofSeconds(5),   // 持有5秒
            this::quickOperation);

        // 复杂操作：长等待时间，长持有时间
        redisUtils.locks().executeWithLock("complex:lock",
            Duration.ofSeconds(10),  // 等待10秒
            Duration.ofMinutes(2),   // 持有2分钟
            this::complexOperation);
    }

    /**
     * 指数退避重试
     */
    public String retryWithBackoff(String lockKey, int maxRetries) {
        for (int attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                return redisUtils.locks().executeWithLock(lockKey,
                    Duration.ofSeconds(1), Duration.ofSeconds(30), () -> {
                        return performCriticalOperation();
                    });
            } catch (Exception e) {
                if (attempt < maxRetries) {
                    // 指数退避：100ms, 200ms, 400ms, 800ms...
                    long backoffMs = (long) (100 * Math.pow(2, attempt - 1));
                    try {
                        Thread.sleep(Math.min(backoffMs, 2000)); // 最多等待2秒
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }
        }
        throw new RuntimeException("重试后仍然失败");
    }
}
```

## 💾 缓存策略优化

### 1. 缓存穿透防护

```java
@Service
public class CachePenetrationProtection {

    /**
     * 使用空值缓存防止缓存穿透
     */
    @RedisCacheable(
        key = "'user:info:' + #userId",
        ttl = 300, // 空值缓存较短时间
        cacheNullValues = true
    )
    public User getUserWithNullProtection(Long userId) {
        User user = userRepository.findById(userId);
        // 即使user为null也会被缓存，防止重复查询数据库
        return user;
    }

    /**
     * 布隆过滤器防护
     */
    @Component
    public class BloomFilterProtection {

        private final BloomFilter<Long> userIdFilter;

        public BloomFilterProtection() {
            // 预期100万用户，1%误判率
            this.userIdFilter = BloomFilter.create(Funnels.longFunnel(), 1000000, 0.01);
        }

        public User getUserWithBloomFilter(Long userId) {
            // 先检查布隆过滤器
            if (!userIdFilter.mightContain(userId)) {
                return null; // 确定不存在
            }

            // 可能存在，继续查询缓存和数据库
            return getUserFromCacheOrDb(userId);
        }

        @PostConstruct
        public void initBloomFilter() {
            // 应用启动时初始化布隆过滤器
            List<Long> existingUserIds = userRepository.findAllUserIds();
            existingUserIds.forEach(userIdFilter::put);
        }
    }
}
```

### 2. 缓存雪崩防护

```java
@Service
public class CacheAvalancheProtection {

    private final Random random = new Random();

    /**
     * 随机TTL防止缓存雪崩
     */
    public void setCacheWithRandomTtl(String key, Object value, Duration baseTtl) {
        // 在基础TTL上随机增加0-20%的时间
        long randomOffset = (long) (baseTtl.toMillis() * random.nextDouble() * 0.2);
        Duration finalTtl = baseTtl.plus(Duration.ofMillis(randomOffset));

        redisUtils.strings().set(key, value, finalTtl);
    }

    /**
     * 多级缓存防护
     */
    @Service
    public class MultiLevelCache {

        private final CaffeineCache localCache;

        public Object getFromMultiLevelCache(String key) {
            // L1: 本地缓存
            Object value = localCache.getIfPresent(key);
            if (value != null) {
                return value;
            }

            // L2: Redis缓存
            value = redisUtils.strings().get(key, Object.class);
            if (value != null) {
                localCache.put(key, value);
                return value;
            }

            // L3: 数据库（带锁防止并发查询）
            return redisUtils.locks().executeWithLock("db:lock:" + key, () -> {
                // 双重检查
                Object dbValue = redisUtils.strings().get(key, Object.class);
                if (dbValue != null) {
                    return dbValue;
                }

                // 从数据库查询
                dbValue = queryFromDatabase(key);
                if (dbValue != null) {
                    // 更新各级缓存
                    setCacheWithRandomTtl(key, dbValue, Duration.ofHours(1));
                    localCache.put(key, dbValue);
                }

                return dbValue;
            });
        }
    }
}
```

### 3. 缓存击穿防护

```java
@Service
public class CacheBreakdownProtection {

    /**
     * 使用分布式锁防止缓存击穿
     */
    public Object getHotDataWithLock(String key) {
        // 先尝试从缓存获取
        Object value = redisUtils.strings().get(key, Object.class);
        if (value != null) {
            return value;
        }

        // 缓存未命中，使用锁保护
        String lockKey = "rebuild:lock:" + key;

        return redisUtils.locks().executeWithLockOrFallback(lockKey,
            Duration.ofSeconds(5), Duration.ofSeconds(30),
            // 主要操作：重建缓存
            () -> {
                // 双重检查
                Object cachedValue = redisUtils.strings().get(key, Object.class);
                if (cachedValue != null) {
                    return cachedValue;
                }

                // 从数据源重建缓存
                Object freshValue = loadDataFromSource(key);
                if (freshValue != null) {
                    redisUtils.strings().set(key, freshValue, Duration.ofHours(2));
                }
                return freshValue;
            },
            // 降级操作：返回默认值或旧数据
            () -> {
                log.warn("无法获取锁重建缓存，返回默认值: {}", key);
                return getDefaultValue(key);
            });
    }

    /**
     * 异步刷新热点数据
     */
    @Scheduled(fixedRate = 300000) // 每5分钟执行一次
    public void refreshHotData() {
        List<String> hotKeys = getHotDataKeys();

        // 并行刷新热点数据
        CompletableFuture<?>[] futures = hotKeys.stream()
            .map(key -> CompletableFuture.runAsync(() -> {
                try {
                    Object freshData = loadDataFromSource(key);
                    if (freshData != null) {
                        redisUtils.strings().set(key, freshData, Duration.ofHours(2));
                    }
                } catch (Exception e) {
                    log.error("刷新热点数据失败: {}", key, e);
                }
            }))
            .toArray(CompletableFuture[]::new);

        CompletableFuture.allOf(futures).join();
    }
}
```

## 🔍 监控与告警

### 1. 性能监控

```java
@Component
public class RedisPerformanceMonitor {

    private final MeterRegistry meterRegistry;
    private final Timer.Sample sample;

    @EventListener
    public void handleRedisOperation(RedisOperationEvent event) {
        // 记录操作延迟
        Timer.builder("redis.operation.duration")
            .tag("operation", event.getOperation())
            .tag("success", String.valueOf(event.isSuccess()))
            .register(meterRegistry)
            .record(event.getDuration(), TimeUnit.MILLISECONDS);

        // 记录慢查询
        if (event.getDuration() > 1000) {
            log.warn("Redis慢操作: {} 耗时 {}ms", event.getOperation(), event.getDuration());
        }
    }

    /**
     * 健康检查
     */
    @HealthIndicator("redis")
    public Health checkRedisHealth() {
        try {
            String testKey = "health:check:" + System.currentTimeMillis();
            redisUtils.strings().set(testKey, "ok", Duration.ofSeconds(10));
            String result = redisUtils.strings().getString(testKey);
            redisUtils.strings().delete(testKey);

            if ("ok".equals(result)) {
                return Health.up()
                    .withDetail("status", "可用")
                    .withDetail("responseTime", "正常")
                    .build();
            }
        } catch (Exception e) {
            return Health.down()
                .withDetail("status", "不可用")
                .withDetail("error", e.getMessage())
                .build();
        }

        return Health.unknown().build();
    }
}
```

### 2. 异常处理

```java
@Component
public class RedisExceptionHandler {

    /**
     * 全局异常处理
     */
    @EventListener
    public void handleRedisException(RedisExceptionEvent event) {
        Exception exception = event.getException();

        if (exception instanceof RedisConnectionFailureException) {
            // 连接异常
            log.error("Redis连接失败", exception);
            triggerAlert("Redis连接异常", exception.getMessage());

        } else if (exception instanceof QueryTimeoutException) {
            // 超时异常
            log.error("Redis操作超时", exception);
            triggerAlert("Redis操作超时", exception.getMessage());

        } else if (exception instanceof RedisCommandExecutionException) {
            // 命令执行异常
            log.error("Redis命令执行失败", exception);
        }
    }

    /**
     * 熔断器模式
     */
    @Component
    public class RedisCircuitBreaker {

        private final CircuitBreaker circuitBreaker;

        public RedisCircuitBreaker() {
            this.circuitBreaker = CircuitBreaker.ofDefaults("redis");
            circuitBreaker.getEventPublisher()
                .onStateTransition(event ->
                    log.info("Redis熔断器状态变更: {} -> {}",
                        event.getStateTransition().getFromState(),
                        event.getStateTransition().getToState()));
        }

        public <T> T executeWithCircuitBreaker(Supplier<T> operation, Supplier<T> fallback) {
            return circuitBreaker.executeSupplier(
                Decorators.ofSupplier(operation).withFallback(fallback));
        }
    }
}
```

通过遵循这些最佳实践，可以确保 Redis Commons 在生产环境中的高性能、高可用性和可维护性。
