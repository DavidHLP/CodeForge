# Redis Commons - 使用示例

## 🚀 快速开始

### Maven 依赖配置

```xml
<dependency>
    <groupId>com.david</groupId>
    <artifactId>redis-commons</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</dependency>
```

### 配置文件设置

```yaml
spring:
  data:
    redis:
      host: localhost
      port: 6379
      password: your_password
      database: 0
      lettuce:
        pool:
          max-active: 20
          max-idle: 10
          min-idle: 5
      commons:
        enabled: true
        cache:
          key-prefix: "app:"
          default-ttl: 3600s
        lock:
          key-prefix: "lock:"
          default-wait-time: 10s
          default-lease-time: 30s
          retry-attempts: 3
        transaction:
          enabled: true
```

## 📚 基础数据操作示例

### String 类型操作

```java
@Service
public class UserCacheService {

    @Autowired
    private RedisUtils redisUtils;

    /**
     * 基础 String 操作示例
     */
    public void stringOperationsDemo() {
        // 1. 设置简单键值对
        redisUtils.strings().set("user:name", "张三");

        // 2. 设置带过期时间的键值对
        redisUtils.strings().set("session:token123", "user-data", Duration.ofHours(2));

        // 3. 获取字符串值
        String userName = redisUtils.strings().getString("user:name");

        // 4. 获取指定类型的值
        UserInfo user = redisUtils.strings().get("user:info:123", UserInfo.class);

        // 5. 检查键是否存在
        boolean exists = redisUtils.strings().hasKey("user:name");

        // 6. 设置过期时间
        redisUtils.strings().expire("user:name", Duration.ofMinutes(30));

        // 7. 获取剩余过期时间
        Long ttl = redisUtils.strings().getExpire("user:name");

        // 8. 删除键
        redisUtils.strings().delete("user:name");
    }

    /**
     * 批量操作示例
     */
    public void batchOperationsDemo() {
        // 1. 批量设置
        Map<String, Object> keyValues = new HashMap<>();
        keyValues.put("user:1", "张三");
        keyValues.put("user:2", "李四");
        keyValues.put("user:3", "王五");
        redisUtils.strings().multiSet(keyValues);

        // 2. 批量获取
        List<String> keys = Arrays.asList("user:1", "user:2", "user:3");
        List<Object> values = redisUtils.strings().multiGet(keys);

        // 3. 批量删除
        Long deletedCount = redisUtils.strings().delete("user:1", "user:2", "user:3");

        // 4. 模式匹配查找
        Set<String> userKeys = redisUtils.strings().scanKeys("user:*");
    }
}
```

### Hash 类型操作

```java
@Service
public class UserProfileService {

    @Autowired
    private RedisUtils redisUtils;

    /**
     * Hash 操作示例
     */
    public void hashOperationsDemo() {
        String userKey = "user:profile:123";

        // 1. 设置单个字段
        redisUtils.hashes().hset(userKey, "name", "张三");
        redisUtils.hashes().hset(userKey, "age", 25);
        redisUtils.hashes().hset(userKey, "email", "zhangsan@example.com");

        // 2. 批量设置字段
        Map<String, Object> profile = new HashMap<>();
        profile.put("city", "北京");
        profile.put("department", "技术部");
        profile.put("position", "Java开发工程师");
        redisUtils.hashes().hmset(userKey, profile);

        // 3. 获取单个字段
        String userName = redisUtils.hashes().hget(userKey, "name", String.class);
        Integer age = redisUtils.hashes().hget(userKey, "age", Integer.class);

        // 4. 获取所有字段
        Map<String, Object> allFields = redisUtils.hashes().hgetall(userKey);

        // 5. 检查字段是否存在
        boolean hasEmail = redisUtils.hashes().hexists(userKey, "email");

        // 6. 获取所有字段名
        Set<String> fieldNames = redisUtils.hashes().hkeys(userKey);

        // 7. 数值增操作
        redisUtils.hashes().hincrBy(userKey, "loginCount", 1);

        // 8. 删除字段
        redisUtils.hashes().hdel(userKey, "email");
    }

    /**
     * 用户积分管理示例
     */
    public void userScoreDemo() {
        String scoreKey = "user:score:123";

        // 初始化用户积分
        Map<String, Object> scores = new HashMap<>();
        scores.put("totalScore", 0);
        scores.put("levelScore", 0);
        scores.put("bonusScore", 0);
        redisUtils.hashes().hmset(scoreKey, scores);

        // 增加积分
        long newTotalScore = redisUtils.hashes().hincrBy(scoreKey, "totalScore", 50);
        redisUtils.hashes().hincrBy(scoreKey, "levelScore", 30);
        redisUtils.hashes().hincrBy(scoreKey, "bonusScore", 20);

        // 查询当前积分
        Map<String, Object> currentScores = redisUtils.hashes().hgetall(scoreKey);
        System.out.println("用户当前积分: " + currentScores);
    }
}
```

### List 类型操作

```java
@Service
public class MessageQueueService {

    @Autowired
    private RedisUtils redisUtils;

    /**
     * 消息队列示例
     */
    public void messageQueueDemo() {
        String queueKey = "message:queue:urgent";

        // 1. 向队列尾部推入消息（生产者）
        redisUtils.lists().rpush(queueKey, "订单支付消息");
        redisUtils.lists().rpush(queueKey, "用户注册消息");
        redisUtils.lists().rpush(queueKey, "系统通知消息");

        // 2. 从队列头部获取消息（消费者）
        String message1 = redisUtils.lists().lpop(queueKey, String.class);
        String message2 = redisUtils.lists().lpop(queueKey, String.class);

        // 3. 查看队列长度
        Long queueLength = redisUtils.lists().llen(queueKey);

        // 4. 查看队列中的消息（不移除）
        List<String> messages = redisUtils.lists().lrange(queueKey, 0, -1, String.class);

        // 5. 获取指定索引的消息
        String firstMessage = redisUtils.lists().lindex(queueKey, 0, String.class);

        // 6. 修改指定索引的消息
        redisUtils.lists().lset(queueKey, 0, "更新后的消息");

        // 7. 裁剪列表（保留指定范围的元素）
        redisUtils.lists().ltrim(queueKey, 0, 99); // 只保留前100个元素
    }

    /**
     * 任务处理队列示例
     */
    public void taskProcessingDemo() {
        String taskQueue = "task:processing";

        // 任务生产者
        for (int i = 1; i <= 10; i++) {
            Task task = new Task("task-" + i, "处理用户数据", System.currentTimeMillis());
            redisUtils.lists().rpush(taskQueue, task);
        }

        // 任务消费者
        while (redisUtils.lists().llen(taskQueue) > 0) {
            Task task = redisUtils.lists().lpop(taskQueue, Task.class);
            if (task != null) {
                System.out.println("处理任务: " + task.getName());
                // 执行任务逻辑...
            }
        }
    }
}
```

### Set 类型操作

```java
@Service
public class TagService {

    @Autowired
    private RedisUtils redisUtils;

    /**
     * 标签管理示例
     */
    public void tagManagementDemo() {
        String userTagsKey = "user:tags:123";

        // 1. 添加用户标签
        redisUtils.sets().sadd(userTagsKey, "Java", "Spring", "Redis", "MySQL");

        // 2. 检查用户是否有某个标签
        boolean hasJavaTag = redisUtils.sets().sismember(userTagsKey, "Java");

        // 3. 获取用户所有标签
        Set<Object> allTags = redisUtils.sets().smembers(userTagsKey);

        // 4. 随机获取一个标签
        String randomTag = redisUtils.sets().srandmember(userTagsKey, String.class);

        // 5. 移除用户标签
        redisUtils.sets().srem(userTagsKey, "MySQL");

        // 6. 获取标签数量
        Long tagCount = redisUtils.sets().scard(userTagsKey);
    }

    /**
     * 用户关系管理示例
     */
    public void userRelationDemo() {
        String user1Followers = "user:followers:123"; // 用户123的粉丝
        String user2Followers = "user:followers:456"; // 用户456的粉丝

        // 添加粉丝
        redisUtils.sets().sadd(user1Followers, "user:789", "user:101", "user:102");
        redisUtils.sets().sadd(user2Followers, "user:101", "user:102", "user:103");

        // 共同粉丝（交集）
        Set<Object> commonFollowers = redisUtils.sets().sinter(user1Followers, user2Followers);

        // 用户123独有的粉丝（差集）
        Set<Object> uniqueFollowers = redisUtils.sets().sdiff(user1Followers, user2Followers);

        // 所有粉丝（并集）
        Set<Object> allFollowers = redisUtils.sets().sunion(user1Followers, user2Followers);

        System.out.println("共同粉丝: " + commonFollowers);
        System.out.println("独有粉丝: " + uniqueFollowers);
        System.out.println("所有粉丝: " + allFollowers);
    }
}
```

### ZSet 类型操作

```java
@Service
public class RankingService {

    @Autowired
    private RedisUtils redisUtils;

    /**
     * 排行榜示例
     */
    public void leaderboardDemo() {
        String leaderboard = "game:leaderboard";

        // 1. 添加用户分数
        redisUtils.zsets().zadd(leaderboard, 1500.0, "player1");
        redisUtils.zsets().zadd(leaderboard, 2300.0, "player2");
        redisUtils.zsets().zadd(leaderboard, 1800.0, "player3");
        redisUtils.zsets().zadd(leaderboard, 2100.0, "player4");

        // 2. 获取用户分数
        Double player1Score = redisUtils.zsets().zscore(leaderboard, "player1");

        // 3. 获取用户排名（从小到大）
        Long player1Rank = redisUtils.zsets().zrank(leaderboard, "player1");

        // 4. 获取用户排名（从大到小）
        Long player1RevRank = redisUtils.zsets().zrevrank(leaderboard, "player1");

        // 5. 获取排行榜前10名
        Set<String> top10 = redisUtils.zsets().zrevrange(leaderboard, 0, 9, String.class);

        // 6. 获取指定分数范围的玩家
        Set<String> midRangeUsers = redisUtils.zsets().zrangeByScore(
            leaderboard, 1500.0, 2000.0, String.class);

        // 7. 获取排行榜总人数
        Long totalPlayers = redisUtils.zsets().zcard(leaderboard);

        // 8. 统计指定分数范围的人数
        Long midRangeCount = redisUtils.zsets().zcount(leaderboard, 1500.0, 2000.0);

        System.out.println("前10名: " + top10);
        System.out.println("中等分数玩家: " + midRangeUsers);
    }

    /**
     * 热点文章排名示例
     */
    public void hotArticlesDemo() {
        String hotArticles = "articles:hot";

        // 文章发布时的初始分数
        redisUtils.zsets().zadd(hotArticles, calculateInitialScore("article:1"), "article:1");
        redisUtils.zsets().zadd(hotArticles, calculateInitialScore("article:2"), "article:2");

        // 用户点赞文章，增加热度分数
        redisUtils.zsets().zincrby(hotArticles, 10.0, "article:1");

        // 用户评论文章，增加热度分数
        redisUtils.zsets().zincrby(hotArticles, 5.0, "article:1");

        // 获取热点文章排行榜
        Set<String> hotRanking = redisUtils.zsets().zrevrange(hotArticles, 0, 19, String.class);

        System.out.println("热点文章Top20: " + hotRanking);
    }

    private double calculateInitialScore(String articleId) {
        // 基于发布时间、作者权重等计算初始分数
        return System.currentTimeMillis() / 1000.0;
    }
}
```

## 🔒 分布式锁使用示例

### 基础锁操作

```java
@Service
public class OrderService {

    @Autowired
    private RedisUtils redisUtils;

    /**
     * 基础分布式锁示例
     */
    public String processOrder(Long orderId) {
        String lockKey = "order:lock:" + orderId;

        try {
            // 尝试获取锁，等待10秒，锁持有30秒
            return redisUtils.locks().tryLock(lockKey, Duration.ofSeconds(10),
                Duration.ofSeconds(30), () -> {
                    // 在锁保护下执行业务逻辑
                    System.out.println("开始处理订单: " + orderId);

                    // 模拟业务处理
                    try {
                        Thread.sleep(5000);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }

                    System.out.println("订单处理完成: " + orderId);
                    return "订单处理成功";
                });
        } catch (Exception e) {
            return "订单处理失败: " + e.getMessage();
        }
    }

    /**
     * 带重试机制的锁示例
     */
    public void processWithRetry(Long orderId) {
        String lockKey = "order:retry:" + orderId;

        try {
            redisUtils.locks().executeWithLockRetry(lockKey,
                Duration.ofSeconds(5), Duration.ofSeconds(30), () -> {
                    // 执行可能失败的业务逻辑
                    return processOrderInternal(orderId);
                });
        } catch (Exception e) {
            System.err.println("重试后仍然失败: " + e.getMessage());
        }
    }

    /**
     * 带降级策略的锁示例
     */
    public String processWithFallback(Long orderId) {
        String lockKey = "order:fallback:" + orderId;

        return redisUtils.locks().executeWithLockOrFallback(lockKey,
            Duration.ofSeconds(1), Duration.ofSeconds(10),
            // 主要操作：完整的订单处理
            () -> {
                System.out.println("执行完整订单处理");
                return processOrderInternal(orderId);
            },
            // 降级操作：快速处理
            () -> {
                System.out.println("执行降级订单处理");
                return processOrderQuickly(orderId);
            });
    }

    private String processOrderInternal(Long orderId) {
        // 完整的订单处理逻辑
        return "订单处理完成";
    }

    private String processOrderQuickly(Long orderId) {
        // 快速处理逻辑
        return "订单快速处理完成";
    }
}
```

### 库存管理锁示例

```java
@Service
public class InventoryService {

    @Autowired
    private RedisUtils redisUtils;

    /**
     * 减库存操作
     */
    public boolean decreaseInventory(Long productId, int quantity) {
        String lockKey = "inventory:lock:" + productId;
        String inventoryKey = "inventory:" + productId;

        return redisUtils.locks().executeWithLock(lockKey, () -> {
            // 获取当前库存
            Integer currentInventory = redisUtils.strings().get(inventoryKey, Integer.class);
            if (currentInventory == null) {
                currentInventory = 0;
            }

            // 检查库存是否足够
            if (currentInventory < quantity) {
                throw new RuntimeException("库存不足");
            }

            // 减库存
            int newInventory = currentInventory - quantity;
            redisUtils.strings().set(inventoryKey, newInventory);

            System.out.println("减库存成功: " + productId + ", 剩余: " + newInventory);
            return true;
        });
    }

    /**
     * 批量减库存操作
     */
    public boolean batchDecreaseInventory(Map<Long, Integer> productQuantities) {
        // 为避免死锁，对产品ID进行排序
        List<Long> sortedProductIds = productQuantities.keySet().stream()
            .sorted()
            .collect(Collectors.toList());

        return redisUtils.locks().executeWithLock("inventory:batch:lock", () -> {
            for (Long productId : sortedProductIds) {
                int quantity = productQuantities.get(productId);
                if (!decreaseInventory(productId, quantity)) {
                    throw new RuntimeException("批量减库存失败，产品ID: " + productId);
                }
            }
            return true;
        });
    }
}
```

## 🔄 事务操作示例

### 声明式事务

```java
@Service
public class AccountService {

    @Autowired
    private RedisUtils redisUtils;

    /**
     * 声明式事务示例
     */
    @RedisTransactional(timeout = 30)
    public void transferMoney(String fromAccount, String toAccount, BigDecimal amount) {
        String fromKey = "account:balance:" + fromAccount;
        String toKey = "account:balance:" + toAccount;

        // 获取转出账户余额
        BigDecimal fromBalance = redisUtils.strings().get(fromKey, BigDecimal.class);
        if (fromBalance == null || fromBalance.compareTo(amount) < 0) {
            throw new RuntimeException("余额不足");
        }

        // 获取转入账户余额
        BigDecimal toBalance = redisUtils.strings().get(toKey, BigDecimal.class);
        if (toBalance == null) {
            toBalance = BigDecimal.ZERO;
        }

        // 更新余额
        redisUtils.strings().set(fromKey, fromBalance.subtract(amount));
        redisUtils.strings().set(toKey, toBalance.add(amount));

        // 记录交易日志
        String logKey = "transaction:log:" + System.currentTimeMillis();
        TransactionLog log = new TransactionLog(fromAccount, toAccount, amount, new Date());
        redisUtils.strings().set(logKey, log, Duration.ofDays(30));

        System.out.println("转账成功: " + fromAccount + " -> " + toAccount + ", 金额: " + amount);
    }
}
```

### 编程式事务

```java
@Service
public class OrderTransactionService {

    @Autowired
    private RedisUtils redisUtils;

    /**
     * 编程式事务示例
     */
    public void createOrder(Order order) {
        redisUtils.tx().execute((operations) -> {
            try {
                // 1. 减库存
                String inventoryKey = "inventory:" + order.getProductId();
                Integer inventory = operations.opsForValue().get(inventoryKey);
                if (inventory == null || inventory < order.getQuantity()) {
                    throw new RuntimeException("库存不足");
                }
                operations.opsForValue().set(inventoryKey, inventory - order.getQuantity());

                // 2. 创建订单
                String orderKey = "order:" + order.getOrderId();
                operations.opsForValue().set(orderKey, order);

                // 3. 更新用户订单列表
                String userOrdersKey = "user:orders:" + order.getUserId();
                operations.opsForList().rightPush(userOrdersKey, order.getOrderId());

                // 4. 记录订单统计
                operations.opsForHash().increment("daily:order:stats",
                    DateUtil.format(new Date(), "yyyy-MM-dd"), 1);

                return null;
            } catch (Exception e) {
                // 事务会自动回滚
                throw new RuntimeException("创建订单失败", e);
            }
        });
    }
}
```

## 📊 缓存注解使用示例

### 基础缓存注解

```java
@Service
public class UserService {

    /**
     * 基础缓存示例
     */
    @RedisCacheable(
        key = "'user:info:' + #userId",
        ttl = 1800, // 30分钟
        condition = "#userId > 0"
    )
    public User getUserById(Long userId) {
        System.out.println("从数据库查询用户: " + userId);
        // 模拟数据库查询
        return userRepository.findById(userId);
    }

    /**
     * 高级缓存示例
     */
    @RedisCacheable(
        key = "'user:profile:' + #userId + ':' + #includePrivate",
        ttl = 3600,
        condition = "#result != null",
        type = UserProfile.class,
        cacheNullValues = false,
        warmUp = true,
        batchSize = 20,
        enableMetrics = true,
        refreshThreshold = 0.2
    )
    public UserProfile getUserProfile(Long userId, boolean includePrivate) {
        System.out.println("从数据库查询用户资料: " + userId);
        return userRepository.findProfileById(userId, includePrivate);
    }

    /**
     * 缓存清除示例
     */
    @RedisEvict(
        keys = {"'user:info:' + #userId", "'user:profile:' + #userId + ':*'"},
        condition = "#result != null"
    )
    public User updateUser(Long userId, User user) {
        System.out.println("更新用户信息: " + userId);
        User updated = userRepository.update(userId, user);

        // 清除相关缓存
        return updated;
    }

    /**
     * 清除所有用户缓存
     */
    @RedisEvict(
        allEntries = true,
        keyPrefix = "user:"
    )
    public void clearAllUserCache() {
        System.out.println("清除所有用户缓存");
    }
}
```

### 多级缓存示例

```java
@Service
public class ProductService {

    /**
     * 多级缓存示例
     */
    @RedisCacheable(
        key = "'product:detail:' + #productId",
        ttl = 7200,
        levels = {CacheLevel.L1, CacheLevel.L2},
        updateStrategy = UpdateStrategy.WRITE_THROUGH,
        warmUp = true,
        warmUpPriority = WarmUpPriority.HIGH
    )
    public ProductDetail getProductDetail(Long productId) {
        System.out.println("查询产品详情: " + productId);
        return productRepository.findDetailById(productId);
    }

    /**
     * 批量缓存预热示例
     */
    @RedisCacheable(
        key = "'hot:products:' + #category",
        ttl = 3600,
        batchSize = 50,
        warmUp = true,
        warmUpDelayMs = 10000 // 延迟10秒预热
    )
    public List<Product> getHotProducts(String category) {
        System.out.println("查询热门产品: " + category);
        return productRepository.findHotProductsByCategory(category);
    }
}
```
