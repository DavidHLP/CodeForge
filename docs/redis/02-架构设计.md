# Redis Commons - 架构设计

## 🏗️ 整体架构概览

Redis Commons 采用分层架构设计，将复杂的 Redis 操作抽象为清晰的模块层次，确保高内聚低耦合的设计原则。整体架构分为以下几个核心层次：

```mermaid
graph TD
    A[应用层 Application Layer] --> B[门面层 Facade Layer]
    B --> C[服务层 Service Layer]
    C --> D[操作层 Operations Layer]
    D --> E[核心层 Core Layer]
    E --> F[基础设施层 Infrastructure Layer]

    A --> A1[注解驱动 @RedisCacheable]
    A --> A2[编程式调用 RedisUtils]
    A --> A3[AOP切面 CacheAspect]

    B --> B1[RedisUtils 门面]
    B --> B2[统一接口封装]

    C --> C1[缓存服务 CacheService]
    C --> C2[锁管理服务 LockService]
    C --> C3[事务管理服务 TransactionService]
    C --> C4[批量操作服务 BatchService]

    D --> D1[String Operations]
    D --> D2[Hash Operations]
    D --> D3[List Operations]
    D --> D4[Set Operations]
    D --> D5[ZSet Operations]
    D --> D6[Lock Operations]
    D --> D7[Transaction Operations]

    E --> E1[RedisTemplate]
    E --> E2[RedissonClient]
    E --> E3[序列化管理]
    E --> E4[连接池管理]

    F --> F1[Spring Data Redis]
    F --> F2[Lettuce Client]
    F --> F3[Redisson Framework]
    F --> F4[Redis Server]

    style A fill:#e1f5fe
    style B fill:#f3e5f5
    style C fill:#e8f5e8
    style D fill:#fff3e0
    style E fill:#fce4ec
    style F fill:#f1f8e9
```

## 🎯 核心设计原则

### 1. 门面模式 (Facade Pattern)

**设计理念**：通过 `RedisUtils` 类作为统一入口，隐藏底层复杂的 Redis 操作实现细节。

```mermaid
classDiagram
    class RedisUtils {
        +strings() RedisStringOperations
        +hashes() RedisHashOperations
        +lists() RedisListOperations
        +sets() RedisSetOperations
        +zsets() RedisZSetOperations
        +locks() RedisLockOperations
        +tx() RedisTransactionOperations
    }

    class RedisStringOperationsImpl {
        +set(key, value, ttl)
        +get(key)
        +delete(key)
        +exists(key)
    }

    class RedisHashOperationsImpl {
        +hset(key, field, value)
        +hget(key, field)
        +hdel(key, field)
        +hgetall(key)
    }

    RedisUtils --> RedisStringOperationsImpl
    RedisUtils --> RedisHashOperationsImpl
    RedisUtils --> RedisListOperationsImpl
    RedisUtils --> RedisSetOperationsImpl
    RedisUtils --> RedisZSetOperationsImpl
    RedisUtils --> RedisLockOperationsImpl
    RedisUtils --> RedisTransactionOperationsImpl
```

### 2. 策略模式 (Strategy Pattern)

**缓存更新策略**：支持多种缓存更新策略，适应不同业务场景。

```mermaid
classDiagram
    class UpdateStrategy {
        <<enumeration>>
        WRITE_THROUGH
        WRITE_BEHIND
        WRITE_AROUND
        REFRESH_AHEAD
    }

    class CacheUpdateHandler {
        <<interface>>
        +handle(key, value, strategy)
    }

    class WriteThroughHandler {
        +handle(key, value, strategy)
    }

    class WriteBehindHandler {
        +handle(key, value, strategy)
    }

    class WriteAroundHandler {
        +handle(key, value, strategy)
    }

    CacheUpdateHandler <|-- WriteThroughHandler
    CacheUpdateHandler <|-- WriteBehindHandler
    CacheUpdateHandler <|-- WriteAroundHandler
    UpdateStrategy --> CacheUpdateHandler
```

### 3. 观察者模式 (Observer Pattern)

**性能监控**：通过事件驱动的方式收集缓存性能指标。

```mermaid
sequenceDiagram
    participant Client
    participant CacheAspect
    participant MetricsCollector
    participant MonitoringSystem

    Client->>CacheAspect: 调用缓存方法
    CacheAspect->>CacheAspect: 执行缓存逻辑
    CacheAspect->>MetricsCollector: 发送性能事件
    MetricsCollector->>MetricsCollector: 统计分析
    MetricsCollector->>MonitoringSystem: 推送监控数据
    CacheAspect-->>Client: 返回结果
```

## 🔧 模块架构详解

### 配置管理模块

**自动配置机制**：基于 Spring Boot 的条件化自动配置，实现零配置启动。

```mermaid
graph LR
    A[RedisCommonsAutoConfiguration] --> B[RedisConfig]
    A --> C[RedissonConfig]
    A --> D[RedisUtils Bean]
    A --> E[CacheAspect Bean]
    A --> F[TransactionAspect Bean]

    B --> B1[RedisTemplate 配置]
    B --> B2[连接池配置]
    B --> B3[序列化配置]

    C --> C1[Redisson 客户端]
    C --> C2[分布式锁配置]
    C --> C3[集群配置]

    D --> D1[操作模块注入]
    D --> D2[事务管理器注入]
    D --> D3[性能监控注入]

    style A fill:#ff9999
    style B fill:#99ccff
    style C fill:#99ff99
```

### 缓存增强模块

**多级缓存架构**：支持 L1(本地缓存) + L2(Redis缓存) + L3(数据源) 的多级缓存体系。

```mermaid
flowchart TD
    Request[客户端请求] --> L1{L1 本地缓存}
    L1 -->|命中| Return1[返回结果]
    L1 -->|未命中| L2{L2 Redis缓存}
    L2 -->|命中| UpdateL1[更新L1缓存]
    UpdateL1 --> Return2[返回结果]
    L2 -->|未命中| L3[L3 数据源查询]
    L3 --> UpdateL2[更新L2缓存]
    UpdateL2 --> UpdateL1_2[更新L1缓存]
    UpdateL1_2 --> Return3[返回结果]

    style L1 fill:#e3f2fd
    style L2 fill:#f3e5f5
    style L3 fill:#e8f5e8
    style Return1 fill:#c8e6c9
    style Return2 fill:#c8e6c9
    style Return3 fill:#c8e6c9
```

### 分布式锁模块

**锁管理架构**：基于 Redisson 实现的高可靠分布式锁机制。

```mermaid
stateDiagram-v2
    [*] --> 尝试获取锁
    尝试获取锁 --> 锁获取成功: 获取成功
    尝试获取锁 --> 锁获取失败: 获取失败/超时

    锁获取成功 --> 执行业务逻辑
    执行业务逻辑 --> 自动续约: 长时间执行
    自动续约 --> 执行业务逻辑
    执行业务逻辑 --> 释放锁: 执行完成
    执行业务逻辑 --> 异常处理: 执行异常

    异常处理 --> 强制释放锁
    强制释放锁 --> [*]
    释放锁 --> [*]
    锁获取失败 --> [*]
```

### 事务管理模块

**声明式事务**：通过 AOP 实现的声明式 Redis 事务管理。

```mermaid
sequenceDiagram
    participant Client
    participant TransactionAspect
    participant RedisTransactionManager
    participant RedisTemplate

    Client->>TransactionAspect: @RedisTransactional 方法调用
    TransactionAspect->>RedisTransactionManager: 开始事务
    RedisTransactionManager->>RedisTemplate: MULTI

    loop 业务操作
        TransactionAspect->>RedisTemplate: 执行 Redis 命令
        RedisTemplate-->>TransactionAspect: 命令入队
    end

    alt 执行成功
        TransactionAspect->>RedisTransactionManager: 提交事务
        RedisTransactionManager->>RedisTemplate: EXEC
        RedisTemplate-->>TransactionAspect: 执行结果
    else 执行失败
        TransactionAspect->>RedisTransactionManager: 回滚事务
        RedisTransactionManager->>RedisTemplate: DISCARD
    end

    TransactionAspect-->>Client: 返回结果
```

## ⚡ 性能优化架构

### 批量操作优化

**智能批量合并**：自动识别并合并批量操作，减少网络 IO 开销。

```mermaid
graph TB
    A[多个单独操作] --> B{批量阈值检测}
    B -->|超过阈值| C[批量操作合并]
    B -->|未达阈值| D[单独操作执行]

    C --> E[Pipeline 批量执行]
    E --> F[结果分发处理]
    F --> G[返回对应结果]

    D --> H[直接执行]
    H --> I[返回结果]

    style C fill:#ffeb3b
    style E fill:#4caf50
    style F fill:#2196f3
```

### 缓存预热机制

**智能预热策略**：基于优先级的缓存预热，提升应用启动后性能。

```mermaid
gantt
    title 缓存预热执行时序
    dateFormat X
    axisFormat %s

    section 应用启动
    Spring容器初始化    :0, 5
    Redis连接建立      :3, 8

    section 预热执行
    高优先级缓存预热    :crit, 8, 15
    中优先级缓存预热    :15, 25
    低优先级缓存预热    :25, 40

    section 服务就绪
    对外提供服务       :40, 45
```

## 🔍 监控与诊断架构

### 性能指标收集

**全链路监控**：从请求到响应的全链路性能指标收集。

```mermaid
flowchart LR
    A[请求入口] --> B[AOP拦截]
    B --> C[开始计时]
    C --> D[执行缓存操作]
    D --> E[记录结果]
    E --> F[计算耗时]
    F --> G[更新指标]
    G --> H[异步上报]

    subgraph 监控指标
        I[命中率统计]
        J[响应时间分布]
        K[错误率统计]
        L[吞吐量统计]
    end

    G --> I
    G --> J
    G --> K
    G --> L

    style B fill:#ff7043
    style G fill:#66bb6a
    style H fill:#42a5f5
```

### 健康检查机制

**多维度健康检查**：Redis 连接状态、缓存命中率、响应时间等多维度健康评估。

```mermaid
pie title Redis Commons 健康检查维度
    "连接状态检查" : 30
    "缓存命中率检查" : 25
    "响应时间检查" : 20
    "内存使用率检查" : 15
    "错误率检查" : 10
```

## 🛡️ 可靠性保障架构

### 异常处理机制

**分层异常处理**：不同层级的异常处理策略，确保系统稳定性。

```mermaid
graph TD
    A[业务异常] --> B{异常类型判断}
    B -->|连接异常| C[连接重试机制]
    B -->|序列化异常| D[降级处理]
    B -->|超时异常| E[熔断机制]
    B -->|业务异常| F[异常包装返回]

    C --> G[自动重连]
    G --> H{重连成功?}
    H -->|是| I[继续执行]
    H -->|否| J[降级处理]

    D --> K[使用默认序列化]
    E --> L[快速失败]
    F --> M[返回业务异常]

    style C fill:#ffcdd2
    style G fill:#dcedc8
    style L fill:#ffecb3
```
