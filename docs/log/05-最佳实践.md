# LogCommons 最佳实践指南

## 日志分类与使用规范

### 1. 日志类型选择原则

**业务日志 (Business)**
- **适用场景**：用户行为追踪、业务流程记录、审计要求
- **使用时机**：关键业务操作、状态变更、重要事件
- **注意事项**：避免记录过于频繁的操作，关注业务价值

```java
// ✅ 正确示例：记录关键业务操作
business().audit("user123", "createOrder", "success", orderId, amount);
business().event("PAYMENT_COMPLETED", userId, orderId, paymentMethod);

// ❌ 错误示例：记录过于细节的操作
business().trace(userId, "validateEmail", "checking_format"); // 过于细节
business().audit(userId, "clickButton", "homepage_banner"); // 非关键操作
```

**性能日志 (Performance)**
- **适用场景**：性能监控、瓶颈分析、容量规划
- **使用时机**：超过阈值的操作、定期性能报告、异常性能事件
- **注意事项**：设置合理的阈值，避免噪音日志

```java
// ✅ 正确示例：监控关键性能指标
if (duration > 1000) { // 只记录超过1秒的操作
    performance().timing("complexQuery", duration, resultCount);
}

// 定期记录系统性能
performance().memory("userCache", cacheSize, maxCacheSize);
performance().qps("apiEndpoint", currentQps, avgResponseTime);

// ❌ 错误示例：记录所有操作
performance().timing("simpleGet", 5); // 过于频繁，性能开销大
```

**安全日志 (Security)**
- **适用场景**：安全审计、威胁检测、合规要求
- **使用时机**：认证授权、敏感操作、异常访问
- **注意事项**：避免记录敏感信息原文，注意脱敏处理

```java
// ✅ 正确示例：安全事件记录
security().login(username, "***", loginSuccess, clientIp, userAgent);
security().threat("SQL_INJECTION", "HIGH", "检测到注入攻击", clientIp);

// ❌ 错误示例：泄露敏感信息
security().login(username, realPassword, loginSuccess); // 泄露密码
security().dataAccess(userId, "查询用户身份证: 123456789012345678"); // 泄露敏感数据
```

**异常日志 (Exception)**
- **适用场景**：错误诊断、系统监控、问题排查
- **使用时机**：捕获异常、系统错误、业务异常
- **注意事项**：分级处理，避免日志洪水

```java
// ✅ 正确示例：分级异常处理
try {
    businessLogic();
} catch (BusinessException e) {
    exception().business("processOrder", e, orderId); // 业务异常
} catch (SystemException e) {
    exception().system("OrderService", e, "HIGH"); // 系统异常，高优先级
} catch (Exception e) {
    exception().system("OrderService", e, "CRITICAL"); // 未知异常，关键级别
}

// ❌ 错误示例：异常处理不当
catch (Exception e) {
    exception().business("error", e); // 信息不足，难以定位
}
```

### 2. 日志级别使用指南

| 级别 | 使用场景 | 示例 |
|------|---------|------|
| **DEBUG** | 开发调试、详细流程 | 参数验证、中间变量值 |
| **INFO** | 正常业务流程、关键操作 | 用户登录、订单创建、定时任务执行 |
| **WARN** | 潜在问题、降级处理 | 连接超时重试、缓存未命中、配置缺失 |
| **ERROR** | 错误异常、业务失败 | 业务异常、数据库错误、外部服务异常 |

## 性能优化最佳实践

### 1. 异步与同步的选择策略

**异步模式适用场景**：
- 高频率日志记录（QPS > 1000）
- 非关键路径上的日志
- 性能敏感的业务逻辑

**同步模式适用场景**：
- 错误和异常日志
- 安全审计日志
- 关键业务事件日志

```java
// 配置示例：根据场景选择处理模式
@Configuration
public class LoggingConfiguration {
    
    @Bean
    @ConfigurationProperties("log-commons.modules.business")
    public BusinessLogConfig businessLogConfig() {
        return BusinessLogConfig.builder()
            .async(true) // 业务日志使用异步，提升性能
            .level(LogLevel.INFO)
            .build();
    }
    
    @Bean
    @ConfigurationProperties("log-commons.modules.security")
    public SecurityLogConfig securityLogConfig() {
        return SecurityLogConfig.builder()
            .async(false) // 安全日志使用同步，确保及时记录
            .level(LogLevel.WARN)
            .build();
    }
}
```

### 2. 缓冲区配置优化

根据业务量和系统资源调整缓冲区配置：

```yaml
log-commons:
  # 高并发场景配置
  buffer-size: 2000          # 增大缓冲区
  flush-interval-seconds: 3   # 缩短刷新间隔
  batch-size: 100            # 增大批处理大小
  
  # 低并发场景配置  
  buffer-size: 500           # 减小缓冲区
  flush-interval-seconds: 10  # 延长刷新间隔
  batch-size: 20             # 减小批处理大小
```

**配置调优指南**：

```java
@Component
public class LogBufferTuner {
    
    @EventListener
    @Async
    public void handleBufferStatusEvent(BufferStatusEvent event) {
        BufferStatus status = event.getStatus();
        
        // 监控缓冲区使用率
        if (status.getUsageRate() > 0.8) {
            log.warn("缓冲区使用率过高: {}%, 建议增大buffer-size", 
                status.getUsageRate() * 100);
        }
        
        // 监控刷新频率
        long timeSinceLastFlush = System.currentTimeMillis() - status.getLastFlushTime();
        if (timeSinceLastFlush > 30000) { // 30秒未刷新
            log.warn("缓冲区刷新间隔过长: {}ms, 建议减小flush-interval-seconds", 
                timeSinceLastFlush);
        }
    }
}
```

### 3. 内存使用优化

**对象池化**：
```java
@Configuration
public class LogOptimizationConfig {
    
    // 使用对象池减少GC压力
    @Bean
    public ObjectPool<StringBuilder> stringBuilderPool() {
        return new GenericObjectPool<>(new StringBuilderPooledObjectFactory());
    }
    
    // 预分配缓冲区
    @Bean
    public LogBufferManager logBufferManager() {
        return LogBufferManager.builder()
            .preallocateBuffers(true) // 预分配内存
            .bufferSize(1000)
            .build();
    }
}
```

**字符串处理优化**：
```java
public class PerformantLogFormatter implements LogFormatter {
    
    private final ThreadLocal<StringBuilder> stringBuilderCache = 
        ThreadLocal.withInitial(() -> new StringBuilder(512));
    
    @Override
    public String format(LogContext context) {
        StringBuilder sb = stringBuilderCache.get();
        sb.setLength(0); // 重用StringBuilder
        
        // 使用StringBuilder构建日志字符串
        sb.append("{\"timestamp\":\"").append(context.getTimestamp())
          .append("\",\"level\":\"").append(context.getLevel())
          .append("\",\"message\":\"").append(context.getMessage())
          .append("\"}");
          
        return sb.toString();
    }
}
```

## 高可用设计实践

### 1. 异常隔离与降级

**多级降级策略**：
```java
@Component
public class ResilientLogOperationExecutor extends LogOperationExecutor {
    
    private final CircuitBreaker circuitBreaker;
    private final AtomicBoolean emergencyMode = new AtomicBoolean(false);
    
    @Override
    public Object execute(LogContext context) {
        // 第一级：正常执行
        if (!emergencyMode.get()) {
            try {
                return super.execute(context);
            } catch (Exception e) {
                // 第二级：降级到简单日志
                return executeWithSimpleLogging(context, e);
            }
        } else {
            // 第三级：紧急模式，仅输出关键信息
            return executeEmergencyLogging(context);
        }
    }
    
    private Object executeWithSimpleLogging(LogContext context, Exception originalError) {
        try {
            // 使用最简单的日志输出
            Logger logger = LoggerFactory.getLogger(context.getModule());
            logger.info("DEGRADED_LOG: {} - {}", 
                context.getOperation(), context.getMessage());
            return null;
        } catch (Exception e) {
            // 第三级降级：启用紧急模式
            emergencyMode.set(true);
            System.err.println("LOG_SYSTEM_FAILURE: " + context.getMessage());
            return null;
        }
    }
    
    private Object executeEmergencyLogging(LogContext context) {
        // 紧急模式：直接输出到System.err
        System.err.println(String.format("EMERGENCY_LOG: %s|%s|%s", 
            context.getTimestamp(), 
            context.getLevel(), 
            context.getMessage()));
        return null;
    }
}
```

### 2. 熔断器模式

```java
@Component
public class LogCircuitBreaker {
    
    private final AtomicInteger failureCount = new AtomicInteger(0);
    private final AtomicLong lastFailureTime = new AtomicLong(0);
    private volatile CircuitState state = CircuitState.CLOSED;
    
    public boolean allowRequest() {
        if (state == CircuitState.OPEN) {
            // 熔断开启状态，检查是否可以尝试恢复
            if (System.currentTimeMillis() - lastFailureTime.get() > 60000) { // 1分钟后尝试恢复
                state = CircuitState.HALF_OPEN;
                return true;
            }
            return false;
        }
        return true;
    }
    
    public void recordSuccess() {
        failureCount.set(0);
        state = CircuitState.CLOSED;
    }
    
    public void recordFailure() {
        int failures = failureCount.incrementAndGet();
        lastFailureTime.set(System.currentTimeMillis());
        
        if (failures >= 10) { // 连续10次失败后熔断
            state = CircuitState.OPEN;
        }
    }
}
```

### 3. 健康检查机制

```java
@Component
public class LogHealthIndicator implements HealthIndicator {
    
    private final LogBufferManager bufferManager;
    private final LogOperationExecutor executor;
    
    @Override
    public Health health() {
        try {
            // 检查缓冲区状态
            BufferStatus bufferStatus = bufferManager.getStatus();
            if (!bufferStatus.isHealthy()) {
                return Health.down()
                    .withDetail("buffer_usage", bufferStatus.getUsageRate())
                    .withDetail("last_flush", bufferStatus.getLastFlushTime())
                    .build();
            }
            
            // 检查执行器状态
            boolean executorHealthy = testExecutor();
            if (!executorHealthy) {
                return Health.down()
                    .withDetail("executor", "failed")
                    .build();
            }
            
            return Health.up()
                .withDetail("buffer_usage", bufferStatus.getUsageRate())
                .withDetail("total_processed", bufferStatus.getTotalProcessed())
                .build();
                
        } catch (Exception e) {
            return Health.down()
                .withDetail("error", e.getMessage())
                .build();
        }
    }
    
    private boolean testExecutor() {
        try {
            // 执行一个简单的测试日志
            LogContext testContext = LogContext.builder()
                .operation("health_check")
                .message("健康检查测试")
                .level(LogLevel.DEBUG)
                .build();
            
            executor.execute(testContext);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
```

## 安全最佳实践

### 1. 敏感信息防护

**多层次脱敏策略**：
```java
@Component
public class EnhancedSensitiveDataMasker implements SensitiveDataMasker {
    
    private final Map<String, Pattern> sensitivePatterns = new HashMap<>();
    private final Set<String> sensitiveFields = new HashSet<>();
    
    @PostConstruct
    public void initializePatterns() {
        // 密码类
        sensitivePatterns.put("password", Pattern.compile("(?i)(password|pwd|secret)[\":\\s]*[\"']([^\"']+)[\"']"));
        
        // 手机号
        sensitivePatterns.put("phone", Pattern.compile("(1[3-9]\\d{9})"));
        
        // 身份证号
        sensitivePatterns.put("idcard", Pattern.compile("(\\d{15}|\\d{18})"));
        
        // 银行卡号
        sensitivePatterns.put("bankcard", Pattern.compile("(\\d{16,19})"));
        
        // API密钥
        sensitivePatterns.put("apikey", Pattern.compile("(?i)(api[_-]?key|access[_-]?token)[\":\\s]*[\"']([^\"']+)[\"']"));
        
        // 邮箱
        sensitivePatterns.put("email", Pattern.compile("([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})"));
    }
    
    @Override
    public String maskSensitiveData(String content) {
        if (StringUtils.isEmpty(content)) {
            return content;
        }
        
        String masked = content;
        
        // 应用所有脱敏规则
        for (Map.Entry<String, Pattern> entry : sensitivePatterns.entrySet()) {
            masked = entry.getValue().matcher(masked)
                .replaceAll(match -> maskByType(entry.getKey(), match.group()));
        }
        
        return masked;
    }
    
    private String maskByType(String type, String original) {
        switch (type) {
            case "password":
                return original.replaceAll("([\"'])[^\"']+([\"'])", "$1***$2");
            case "phone":
                return original.replaceAll("(\\d{3})\\d{4}(\\d{4})", "$1****$2");
            case "email":
                return original.replaceAll("([^@]{1,3})[^@]*(@.*)", "$1***$2");
            case "idcard":
                return original.replaceAll("(\\d{4})\\d{10}(\\d{4})", "$1**********$2");
            case "bankcard":
                return original.replaceAll("(\\d{4})\\d{8,11}(\\d{4})", "$1********$2");
            default:
                return "***";
        }
    }
}
```

### 2. 访问控制与审计

```java
@Component
public class LogSecurityAspect {
    
    @Around("@annotation(LogSecure)")
    public Object secureLogging(ProceedingJoinPoint joinPoint, LogSecure logSecure) throws Throwable {
        String userId = getCurrentUserId();
        String operation = joinPoint.getSignature().getName();
        
        // 检查日志记录权限
        if (!hasLoggingPermission(userId, logSecure.level())) {
            security().threat("UNAUTHORIZED_LOGGING", "MEDIUM", 
                "未授权的日志记录尝试", userId, operation);
            return joinPoint.proceed(); // 不记录日志但继续执行业务逻辑
        }
        
        // 记录日志访问审计
        security().dataAccess(userId, "log_operation", "write", operation);
        
        return joinPoint.proceed();
    }
    
    private boolean hasLoggingPermission(String userId, LogLevel level) {
        // 根据用户角色和日志级别检查权限
        UserRole role = getUserRole(userId);
        return role.canLog(level);
    }
}
```

### 3. 数据传输安全

```java
@Configuration
public class LogSecurityConfiguration {
    
    // 日志传输加密
    @Bean
    public LogTransmissionEncryption logEncryption() {
        return new LogTransmissionEncryption(
            keyManagementService.getLogEncryptionKey());
    }
    
    // 安全的日志存储配置
    @Bean
    public SecurityLogAppender securityLogAppender() {
        SecurityLogAppender appender = new SecurityLogAppender();
        appender.setEncryption(true);
        appender.setIntegrityCheck(true);
        appender.setAccessControl(true);
        return appender;
    }
}
```

## 监控与告警实践

### 1. 关键指标监控

```java
@Component
public class LogMonitoringService {
    
    private final MeterRegistry meterRegistry;
    private final Counter errorCounter;
    private final Timer performanceTimer;
    private final Gauge bufferUsageGauge;
    
    @EventListener
    public void handleLogMetricsEvent(LogMetricsEvent event) {
        // 错误率监控
        if (event.isError()) {
            errorCounter.increment(
                Tags.of("type", event.getType(), "level", event.getLevel()));
        }
        
        // 性能监控
        performanceTimer.record(event.getDuration(), TimeUnit.MILLISECONDS,
            Tags.of("operation", event.getOperation()));
        
        // 告警检查
        checkAlarmConditions(event);
    }
    
    private void checkAlarmConditions(LogMetricsEvent event) {
        // 错误率过高告警
        double errorRate = calculateErrorRate();
        if (errorRate > 0.1) { // 错误率超过10%
            sendAlarm("ERROR_RATE_HIGH", 
                "日志组件错误率过高: " + (errorRate * 100) + "%");
        }
        
        // 性能告警
        if (event.getDuration() > 5000) { // 超过5秒
            sendAlarm("LOG_PERFORMANCE_SLOW", 
                "日志操作执行缓慢: " + event.getDuration() + "ms");
        }
        
        // 缓冲区使用率告警
        double bufferUsage = getBufferUsageRate();
        if (bufferUsage > 0.9) { // 使用率超过90%
            sendAlarm("BUFFER_USAGE_HIGH", 
                "日志缓冲区使用率过高: " + (bufferUsage * 100) + "%");
        }
    }
}
```

### 2. 自动化运维

```java
@Component
@ConditionalOnProperty("log-commons.auto-tuning.enabled")
public class LogAutoTuner {
    
    @Scheduled(fixedRate = 300000) // 每5分钟检查一次
    public void autoTuneConfiguration() {
        LogMetrics metrics = metricsCollector.getRecentMetrics();
        
        // 自动调整缓冲区大小
        if (metrics.getBufferOverflowRate() > 0.05) {
            int newBufferSize = (int) (currentBufferSize * 1.2);
            updateBufferSize(newBufferSize);
            log.info("自动调整缓冲区大小: {} -> {}", currentBufferSize, newBufferSize);
        }
        
        // 自动调整刷新间隔
        if (metrics.getAvgFlushLatency() > 10000) { // 平均刷新延迟超过10秒
            int newInterval = Math.max(flushInterval - 1, 1);
            updateFlushInterval(newInterval);
            log.info("自动调整刷新间隔: {}s -> {}s", flushInterval, newInterval);
        }
        
        // 自动切换处理模式
        if (metrics.getQps() > 5000) { // QPS超过5000时强制异步
            forceAsyncMode(true);
        } else if (metrics.getQps() < 100) { // QPS低于100时可以同步
            forceAsyncMode(false);
        }
    }
}
```

## 故障排查指南

### 1. 常见问题诊断

**问题1：日志未输出**
```java
@Component
public class LogDiagnosticService {
    
    public DiagnosticResult diagnoseLogs() {
        DiagnosticResult result = new DiagnosticResult();
        
        // 检查组件初始化状态
        if (!isLogUtilsInitialized()) {
            result.addIssue("LogUtils未正确初始化", "检查Spring配置和依赖注入");
        }
        
        // 检查日志级别配置
        if (isLogLevelTooHigh()) {
            result.addIssue("日志级别过高", "调整日志级别配置");
        }
        
        // 检查缓冲区状态
        if (isBufferStuck()) {
            result.addIssue("缓冲区阻塞", "检查刷新机制和存储系统");
        }
        
        return result;
    }
}
```

**问题2：性能影响业务**
```java
public class PerformanceAnalyzer {
    
    public void analyzePerformanceImpact() {
        // 分析同步日志的性能影响
        long avgSyncTime = performanceMetrics.getAvgSyncLogTime();
        if (avgSyncTime > 50) { // 超过50ms
            log.warn("同步日志性能影响较大，建议切换异步模式");
        }
        
        // 分析内存使用情况
        long bufferMemory = getBufferMemoryUsage();
        if (bufferMemory > 100 * 1024 * 1024) { // 超过100MB
            log.warn("日志缓冲区内存使用过高: {}MB", bufferMemory / 1024 / 1024);
        }
    }
}
```

### 2. 调试配置

```yaml
# 开发环境调试配置
logging:
  level:
    com.david.log.commons: DEBUG
    
log-commons:
  debug-mode: true
  modules:
    business:
      level: DEBUG
    performance:
      level: DEBUG  
    security:
      level: DEBUG
    exception:
      level: DEBUG
  metrics:
    enabled: true
    detailed: true
```

### 3. 监控仪表板配置

```yaml
# Prometheus监控配置
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: ${spring.application.name}
      environment: ${spring.profiles.active}
```

通过遵循这些最佳实践，可以确保 LogCommons 组件在生产环境中稳定、高效、安全地运行，为业务系统提供可靠的日志记录服务。
